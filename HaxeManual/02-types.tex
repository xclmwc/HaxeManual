\chapter{类型}
\label{types}

Haxe编译器有丰富的类型系统，可以更好地在编译期发现类型错误。类型错误是对类型的非法操作，如除以一个字符串，调用函数时缺少（或增加）参数。

一些语言为了达到类型安全，需要显示声明变量类型：

\begin{lstlisting}
var myButton:MySpecialButton = new MySpecialButton(); // As3
MySpecialButton* myButton = new MySpecialButton(); // C++ 
\end{lstlisting}
Haxe中可以不显示声明变量类型，因为编译器可以推断出变量类型：

\begin{lstlisting}
var myButton = new MySpecialButton(); // Haxe
\end{lstlisting}
稍后我们会在\Fullref{type-system-type-inference}中详细探讨类型推断。从上面代码中可以知道\expr{myButton}是\type{MySpecialButton}的一个\emph{实例}。

Haxe类型系统有7种类型组：

\begin{description}
 \item[\emph{Class 对象}:] 类或接口的实例
 \item[\emph{Enum 对象}:] Haxe枚举的实例
 \item[\emph{Structure}:] 匿名结构体，例如：域（Field）的集合
 \item[\emph{Function}:] 几个参数和一个返回值的复合类型\footnote{函数类型，译者注}
 \item[\emph{Dynamic}:] 能与任何类型兼容的通配类型
 \item[\emph{Abstract}:] 代表一种运行时类型的编译期类型
 \item[\emph{Monomorph}:] 未知类型，将在后期推出
\end{description}

后面的章节中会介绍每种类型组和它们之间的联系。

\define{复合类型}{define-compound-type}{复合类型是一种包含子类型的类型，可以包含任何类型参数的类型和函数类型。}

\section{基础类型}
\label{types-basic-types}

\emph{基础类型}有\type{Bool（布尔）}, \type{Float（浮点）}和\type{Int（整型）}。在语法中很容易从以下值辨别：

\begin{itemize}
	\item \expr{true}和\expr{false}是\type{Bool}型。
	\item \expr{1}，\expr{0}，\expr{-1}和\expr{0xFF0000}是\type{Int}型。
	\item \expr{1.0}，\expr{0.0}，\expr{-1.0}，\expr{1e10}是\type{Float}型.
\end{itemize}

Haxe中的基础类型并不是\tref{类}{types-class-instance}。它们由\tref{抽象类型}{types-abstract}实现，由编译器内部处理，后面章节会详细说明。

\subsection{数字类型}
\label{types-numeric-types}

\define[类型]{Float}{define-float}{IEEE 64位双精度浮点数}

\define[类型]{Int}{define-int}{整数}
\type{Int}可以在任何时候转换为\type{Float}，但是反之不然。将\type{Float}转换为\type{Int}可能会损失精度，并且不允许隐式转换。

\subsection{溢出}
\label{types-overflow}

为了更好的性能，Haxe编译器不会强制改变任何溢出行为。检查溢出的工作交给了目标平台。以下是需要注意的几种平台溢出行为：

\begin{description}
 \item[C++, Java, C\#, Neko, Flash:] 有符号32位整型符合通常的溢出行为。
 \item[PHP, JS, Flash 8:] 没有本地\emph{Int}类型, 当超过他们的浮点数限制时(2\textsuperscript{52})将会引起精度损失。
\end{description}

可以选择\emph{haxe.Int32}或者\emph{haxe.Int64}来避免各平台的溢出行为差异。


\subsection{运算符}
\label{types-numeric-operators}

以下是Haxe的运算符，按优先级递减排序：

\begin{center}
\begin{tabular}{| l | l | l | l | l |}
	\hline
	\multicolumn{5}{|c|}{四则运算} \\ \hline
	运算符 & 运算 &  操作数1 & 操作数2 & 返回值 \\ \hline
	\expr{++}& 递增 & \type{Int} & N/A & \type{Int}\\
	& & \type{Float} & N/A & \type{Float}\\
	\expr{--} & 递减 & \type{Int} & N/A & \type{Int}\\
	& & \type{Float} & N/A & \type{Float}\\
	\expr{+} & 加 & \type{Float} & \type{Float} & \type{Float} \\
	& & \type{Float} & \type{Int} & \type{Float} \\
	& & \type{Int} & \type{Float} & \type{Float} \\
	& & \type{Int} & \type{Int} & \type{Int} \\
	\expr{-} & 减 & \type{Float} & \type{Float} & \type{Float} \\
	& & \type{Float} & \type{Int} & \type{Float} \\
	& & \type{Int} & \type{Float} & \type{Float} \\
	& & \type{Int} & \type{Int} & \type{Int} \\
	\expr{*} & 乘 & \type{Float} & \type{Float} & \type{Float} \\
	& & \type{Float} & \type{Int} & \type{Float} \\
	& & \type{Int} & \type{Float} & \type{Float} \\
	& & \type{Int} & \type{Int} & \type{Int} \\	
	\expr{/} & 除 & \type{Float} & \type{Float} & \type{Float} \\
	& & \type{Float} & \type{Int} & \type{Float} \\
	& & \type{Int} & \type{Float} & \type{Float} \\
	& & \type{Int} & \type{Int} & \type{Float} \\
	\expr{\%} & 取模 & \type{Float} & \type{Float} & \type{Float} \\
	& & \type{Float} & \type{Int} & \type{Float} \\
	& & \type{Int} & \type{Float} & \type{Float} \\
	& & \type{Int} & \type{Int} & \type{Int} \\	 \hline
	\multicolumn{5}{|c|}{比较} \\ \hline
	运算符 & 运算 & 操作数1 & 操作数2 & 返回值 \\ \hline
	\expr{==} & 等 & \type{Float/Int} & \type{Float/Int} & \type{Bool} \\
	\expr{!=} & 不等 & \type{Float/Int} & \type{Float/Int} & \type{Bool} \\
	\expr{<} & 小于 & \type{Float/Int} & \type{Float/Int} & \type{Bool} \\
	\expr{<=} & 小于等于 & \type{Float/Int} & \type{Float/Int} & \type{Bool} \\
	\expr{>} & 大于 & \type{Float/Int} & \type{Float/Int} & \type{Bool} \\
	\expr{>=} & 大于等于 & \type{Float/Int} & \type{Float/Int} & \type{Bool} \\ \hline
	\multicolumn{5}{|c|}{位运算} \\ \hline
	运算符 & 运算 & 操作数1 & 操作数2 & 返回值 \\ \hline
	\expr{\textasciitilde} & 取反 & \type{Int} & N/A & \type{Int} \\	
	\expr{\&} & 与 & \type{Int} & \type{Int} & \type{Int} \\	
	\expr{|} & 或 & \type{Int} & \type{Int} & \type{Int} \\	
	\expr{\^} & 异或 & \type{Int} & \type{Int} & \type{Int} \\	
	\expr{<<} & 左移 & \type{Int} & \type{Int} & \type{Int} \\
	\expr{>>} & 右移 & \type{Int} & \type{Int} & \type{Int} \\
	\expr{>>>} & 无符号右移 & \type{Int} & \type{Int} & \type{Int} \\ \hline
\end{tabular}
\end{center}

\emph{枚举类型（Enum）等于:}
\begin{description}
	\item[无参数枚举] 一般代表相同值, 所以\expr{MyEnum.A == MyEnum.A}. 
	\item[带参数枚举] 可以使用\expr{a.equals(b)}（\expr{Type.enumEquals()}的简单版） 比较.
\end{description}

\emph{动态类型（Dynamic）等于:}
比较包含至少一个未确定值时，其结果依赖于对应平台。

\subsection{布尔（Bool）}
\label{types-bool}

\define[类型]{布尔（Bool）}{define-bool}{只是\emph{true}或者\emph{false}的值。}

布尔值常常用在\tref{\expr{if}}{expression-if}和\tref{\expr{while}}{expression-while}表达式中使用。
以下操作符接收并返回布尔值：

\begin{itemize}
	\item \expr{\&\&} (且)
	\item \expr{||} (或)
	\item \expr{!} (非)
\end{itemize}

Haxe在计算布尔表达式时，会确保在运行时只会从左向右计算，并且只做必要的运算。例如：像\expr{A \&\& B}，会先计算\expr{A}，如果执行结果为\expr{true}才会计算\expr{B}的值。同样的，\expr{A || B}，如果\expr{A}运算结果为\expr{true}就不会再计算\expr{B}，因为这时候\expr{B}的值不会影响计算结果。在下面这种情况下尤为需要注意：

\begin{lstlisting}
if (object != null && object.field == 1) { }
\end{lstlisting}

如果\expr{object}是\expr{null}，调用\expr{object.field}可能会引起运行时错误，但是\expr{object != null}的检查可以避免引发该错误。

\subsection{Void}
\label{types-void}

\define[类型]{Void}{define-void}{Void代表没有类型，被用来表示没有值（一般用在function）。}

\type{Void}在类型系统中是一个特殊的存在，因为它根本不是一个类型。常常用在function参数和返回类型中代表没有类型。
在“Hello World”示例代码中Void已经出现过了：

\haxe{assets/HelloWorld.hx}

函数（function）类型将在\Fullref{types-function}详细说明。这里简单介绍下：上面例子中的\expr{main}函数的类型是\type{Void->Void}，表示没有参数和返回值。
Haxe的变量或字段不能是\type{Void}类型，下面的声明是非法的：

\begin{lstlisting}
// 参数和变量不能是Void
var x:Void;
\end{lstlisting}

\section{空值（Nullability）}
\label{types-nullability}

\define{可为空（nullable）}{define-nullable}{如果类型值可以被赋值为\expr{null}，那么这个类型就是可为空值的（\emph{nullable}）。}

一般来说，编程语言对空值都有一个明确的定义。由于一些目标语言何值都可以是\expr{null}，一些语言则不允许有\expr{null}，Haxe不得不做出一定妥协。这样造成了两种情况：

\define{静态语言}{define-static-target}{静态语言使用自己的类型系统，没有\expr{null}值。对应语言：\target{Flash}，\target{C++}，\target{Java}，\target{C\#}}

\define{动态语言}{define-dynamic-target}{动态语言对类型的要求则要宽松很多，允许基础值为\expr{null}。对应语言：\target{JavaScript}，\target{PHP}，\target{Neko}，\target{Flash 6-8}}

动态语言中使用\expr{null}不会有任何问题。不过在静态语言中就需要做些处理了，基础类型初始化时会使用默认值。

\define{默认值}{define-default-value}{
	静态语言中使用以下默认值：
	\begin{description}
		\item[\type{Int}:] \expr{0}
		\item[\type{Float}:] \target{Flash}中是\expr{NaN}，其他则是\expr{0.0}。
		\item[\type{Bool}:] \expr{false}
	\end{description}
}

如果需要在静态语言中使用\expr{null}值，那么则需要用\type{Null$<$T$>$}包裹基础类型：

\begin{lstlisting}
// 静态语言中
var a:Int = null;// 非法声明
var b:Null<Int> = null; // 合法声明
\end{lstlisting}

同样的，如果没有用Null标签，基础类型不能和\expr{null}比较：

\begin{lstlisting}
// 静态语言中
var a : Int = 0;
if( a == null ) { ... } // 非法
var b : Null<Int> = 0;
if( b != null ) { ... } // 合法
\end{lstlisting}

在\tref{类型转换unification}中也符合以上限制。

\define[类型]{\expr{Null<T>}}{define-null-t}{静态语言中可以为\type{Null<Int>}，\type{Null<Float>}，\type{Null<Bool>}赋值\expr{null}。动态语言中则不会改变原本行为。\type{Null<T>}也可以用于其他类型来提供\expr{null}值。}

静态语言中将\expr{null}值的变量赋值给基础类型变量，将会使用默认值赋值：

\begin{lstlisting}
var n : Null<Int> = null;
var a : Int = n;
trace(a); // `静态语言中`a`为`0
\end{lstlisting}

\subsection{可选参数和空值}
\label{types-nullability-optional-arguments}

可选参数也需要注意空值。
特别是，可为空的Haxe可选参数和不能为空的本地语言可选参数必然会有一些区别。当使用问好标记可选参数时会造成这些不同：
\begin{lstlisting}
// x是本地Int类型 (不能为null)
function foo(x : Int = 0) {}
// y是Null<Int> (可以为null)
function bar( ?y : Int) {}
// z也是Null<Int>
function opt( ?z : Int = -1) {}
\end{lstlisting}

\trivia{Argument和Parameter}{在某些语言中, \emph{argument}和\emph{parameter}没有什么区别。在Haxe中\emph{argument}指的的方法参数，\emph{parameter}则是\Fullref{type-system-type-parameters}。不过翻译时都翻译为参数。}

\section{类}
\label{types-class-instance}

和其他面对对象语言一样，类是Haxe大部分程序中的主要数据载体。Haxe中每个类都有显式类名，隐式路径，以及0个以上字段。这里我们只大体讲解类的结构和类之间的关系，类字段将在\Fullref{class-field}中讲解。

以下代码作为本节的基础代码：

\haxe{assets/Point.hx}

在语义上，这个类代表了一个二维空间的点。不过这里我们更关心的是类的结构：

\begin{itemize}
	\item \expr{class}关键字声明了一个类。
	\item \type{Point}是类名，Haxe类的命名规则在\tref{类型命名规则}{define-identifier}中说明。
	\item \expr{$\left\{\right\}$}中是类的字段。
	\item 其中包含两个\emph{属性}字段，\type{Int}型的\expr{x}和\expr{y}。
	\item \expr{new}方法则是该类的\emph{构造方法}。
	\item 还有一个\expr{toString}方法.
\end{itemize}
Haxe中有一个特殊的类型可以和所有类兼容：
\todo{也许可以翻译为泛型？}

\define[类型]{\expr{Class$<$T$>$}}{define-class-t}{该类型能和所有类兼容，所以任何类都可以被赋值给该类型（不是他们的实例）。在编译器， \type{Class<T>}是所有类的共同基础类型。但是在生成的代码中，这个关系不能被反射。

当API中需要一个值是一个不明确的类（不是类的实例），该类型非常有用。这个适用于\tref{Haxe反射API}{std-reflection}中的几种情况。}

\subsection{类构造方法}
\label{types-class-constructor}

类的实例由构造方法生成，一个生成\emph{实例}的过程。实例的另外一个名称是\emph{对象}。然而，我们更喜欢用实例这个称呼来强调类实例和\tref{枚举实例}类似。

\begin{lstlisting}
var p = new Point(-1, 65);
\end{lstlisting}
这会生成一个\type{Point}的实例，并被赋值给\expr{p}。\type{Point}构造方法接收两个参数，\expr{-1}和\expr{65}，分别并赋值给实例的\expr{x}和\expr{y}属性(在\Fullref{types-class-instance}中查看源代码)。我们会在\ref{expression-new}节中了解\expr{new}的确切含义。现在我们只需要知道它是构造方法并返回一个合适的对象。


\subsection{继承}
\label{types-class-inheritance}

类可以继承其他类的结构，Haxe中继承的关键字是\expr{extends}：

\haxe{assets/Point3.hx}
任何\type{Point3}的实例也是\type{Point}的实例。\type{Point}是\type{Point3}的\emph{父类}，\type{Point3}是\type{Point}的\emph{子类}。一个类可以有许多子类，但是只有一个父类。一个类的父类可以指这个类的父类，爷类，等等，等等。

上面的代码和\type{Point}类很像，有两个新结构：
\begin{itemize}
 \item \expr{extends Point}表明该类继承于\type{Point}
 \item \expr{super(x, y)}调用父类的构造方法，这个例子中就是\expr{Point.new}
\end{itemize}
可以不用定义子类的构造方法，但如果定义了，子类的构造方法中必须调用\expr{super()}。和某些面向对象语言不一样的是，super可以出现在构造方法中的任何地方，不必是第一句表达式。

一个类可以重写父类的\tref{方法}，关键字是\expr{override}。关于使用限制和效果将在\Fullref{class-field-overriding}详细讲解。


\subsection{接口}
\label{types-interfaces}

An interface can be understood as the signature of a class because it describes the public fields of a class. Interfaces do not provide implementations but pure structural information:
接口可以被理解为一个类的特征说明，因为它描述了一个类的公开字段。接口不提供具体实现，只描述结构信息：

\begin{lstlisting}
interface Printable {
	public function toString():String;
}
\end{lstlisting}
和类的语法很像，不过有以下区别：

\begin{itemize}
	\item \expr{interface}关键字而不是\expr{class}关键字
	\item 方法里没有任何\tref{表达式}{expression}
	\item 每个字段都必须有类型声明
\end{itemize}
接口和\tref{结构化子类型}{type-system-structural-subtyping}不一样，它描述了类之间的\emph{静态关系}。如果一个类被描述成这样，那么它会被认为与接口兼容：


\begin{lstlisting}
class Point implements Printable { }
\end{lstlisting}
这里，\expr{implements}关键字表明了\type{Point}相当于\type{Printable}的子类。例：每个\type{Point}的实例都是\type{Printable}的实例，但是一个类只能有一个父类，却可以有很多接口。用多个\expr{implements}引入多个接口：

\begin{lstlisting}
class Point implements Printable
  implements Serializable
\end{lstlisting}

编译器会检查类中是否包含了\expr{implements}中的所有字段。如果类或者其父类提供了字段的实现，该字段就被认为已经实现了。

接口字段不只是方法。也可以是变量和属性：

\haxe{assets/InterfaceWithVariables.hx}

接口可以继承其他多个接口，使用\expr{extends}关键字：
\begin{lstlisting}
interface Debuggable extends Printable extends Serializable
\end{lstlisting}

\trivia{继承语法}{Haxe 3.0之前的版本多个\expr{implements}关键字需要用逗号分开。我们决定使用Java规范然后就去掉了逗号。这是Haxe 2和Haxe 3的区别。}

\section{枚举实例}
\label{types-enum-instance}

Haxe提供了非常强大的枚举类型，实际上是\emph{代数数据类型}（ADT）\footnote{\url{https://en.wikipedia.org/wiki/Algebraic_data_type}}，不过不能含有任何\tref{表达式}{expression}，它们很适合用来描述数据结构：

\haxe{assets/Color.hx}
Semantically, this enum describes a color which is either red, green, blue or a specified RGB value. The syntactic structure is as follows:
这个枚举包含了红绿蓝和带有数值的RGB颜色。语法结构如下：
\begin{itemize}
	\item \expr{enum}关键字声明枚举类型。
	\item \type{Color}是枚举名，命名规则符合\tref{类型标识符}{define-identifier}。
	\item \expr{$\left\{\right\}$}里包含的是\emph{枚举构造方法}。
	\item \expr{Red}，\expr{Green}和\expr{Blue}没有参数。 
	\item \expr{Rgb}有三个\type{Int}型参数：\expr{r}，\expr{g}，\expr{b}。
\end{itemize}
The Haxe type system provides a type which unifies with all enum types:
Haxe提供了一个类型统一所有枚举类型：

\define[类型]{\expr{Enum$<$T$>$}}{define-enum-t}{这个类型和所有枚举类型兼容。在编译期，\type{Enum<T>}可以看作所有枚举类型的公共基础类型。不过这种关系在生成的代码中是不能被反射的。} 

\subsection{枚举构造方法}
\label{types-enum-constructor}

与类的构造方法类似，枚举用构造方法实例化。不过，与类不同的是，枚举提供了多个构造方法，并且只需要方法名就能调用：

\begin{lstlisting}
var a = Red;
var b = Green;
var c = Rgb(255, 255, 0);
\end{lstlisting}
变量\expr{a}，\expr{b}，\expr{c}是Color的实例。变量\expr{c}使用\expr{Rgb}构造方法初始化，255，255，0是其构造方法参数。

所有枚举实例都能被赋值给一个特别类型\type{EnumValue}。

\define[类型]{EnumValue}{define-enumvalue}{EnumValue是一个统一所有枚举实例的特别类型。Haxe标志库用来提供一个对所有枚举的操作，用户代码中可以用在不能确定是什么枚举实例的地方。}

需要特别注意枚举类型和枚举构造方法：

\haxe{assets/EnumUnification.hx}

If the commented line is uncommented, the program does not compile because \expr{Red} (an enum constructor) cannot be assigned to a variable of type \type{Enum<Color>} (an enum type). The relation is analogous to a class and its instance.


\trivia{Concrete type parameter for \type{Enum$<$T$>$}}{One of the reviewers of this manual was confused about the difference between \type{Color} and \type{Enum<Color>} in the example above. Indeed, using a concrete type parameter there is pointless and only serves the purpose of demonstration. Usually we would omit the type there and let \tref{type inference}{type-system-type-inference} deal with it.

However, the inferred type would be different from \type{Enum<Color>}. The compiler infers a pseudo-type which has the enum constructors as ``fields''. As of Haxe 3.2.0, it is not possible to express this type in syntax but also, it is never necessary to do so.}



\subsection{Using enums}
\label{types-enum-using}

Enums are a good choice if only a finite set of values should be allowed. The individual \tref{constructors}{types-enum-constructor} then represent the allowed variants and enable the compiler to check if all possible values are respected. This can be seen here:

\haxe{assets/Color2.hx}

After retrieving the value of \expr{color} by assigning the return value of \expr{getColor()} to it, a \tref{\expr{switch} expression}{expression-switch} is used to branch depending on the value. The first three cases \expr{Red}, \expr{Green} and \expr{Blue} are trivial and correspond to the constructors of \type{Color} that have no arguments. The final case \expr{Rgb(r, g, b)} shows how the argument values of a constructor can be extracted: they are available as local variables within the case body expression, just as if a \tref{\expr{var} expression}{expression-var} had been used.

Advanced information on using the \expr{switch} expression will be explored later in the section on \tref{pattern matching}{lf-pattern-matching}.


\section{Anonymous Structure}
\label{types-anonymous-structure}

Anonymous structures can be used to group data without explicitly creating a type. The following example creates a structure with two fields \expr{x} and \expr{name}, and initializes their values to \expr{12} and \expr{"foo"} respectively:

\haxe{assets/Structure.hx}
The general syntactic rules follow:

\begin{enumerate}
	\item A structure is enclosed in curly braces \expr{$\left\{\right\}$} and
	\item Has a \emph{comma-separated} list of key-value-pairs.
	\item A \emph{colon} separates the key, which must be a valid \tref{identifier}{define-identifier}, from the value.
	\item\label{valueanytype} The value can be any Haxe expression.
\end{enumerate}
Rule \ref{valueanytype} implies that structures can be nested and complex, e.g.:

\todo{please reformat}

\begin{lstlisting}
var user = {
  name : "Nicolas",
	age : 32,
	pos : [
	  { x : 0, y : 0 },
		{ x : 1, y : -1 }
  ],
};
\end{lstlisting}
Fields of structures, like classes, are accessed using a \emph{dot} (\expr{.}) like so:

\begin{lstlisting}
// get value of name, which is "Nicolas"
user.name;
// set value of age to 33
user.age = 33;
\end{lstlisting}
It is worth noting that using anonymous structures does not subvert the typing system. The compiler ensures that only available fields are accessed, which means the following program does not compile:

\begin{lstlisting}
class Test {
  static public function main() {
    var point = { x: 0.0, y: 12.0 };
    // { y : Float, x : Float } has no field z
    point.z;
  }
}
\end{lstlisting}
The error message indicates that the compiler knows the type of \expr{point}: It is a structure with fields \expr{x} and \expr{y} of type \type{Float}. Since it has no field \expr{z}, the access fails.
The type of \expr{point} is known through \tref{type inference}{type-system-type-inference}, which thankfully saves us from using explicit types for local variables. However, if \expr{point} was a field, explicit typing would be necessary:

\begin{lstlisting}
class Path {
    var start : { x : Int, y : Int };
    var target : { x : Int, y : Int };
    var current : { x : Int, y : Int };
}
\end{lstlisting}
To avoid this kind of redundant type declaration, especially for more complex structures, it is advised to use a \tref{typedef}{type-system-typedef}:

\begin{lstlisting}
typedef Point = { x : Int, y : Int }

class Path {
    var start : Point;
    var target : Point;
    var current : Point;
}
\end{lstlisting}


\subsection{JSON for Structure Values}
\label{types-structure-json}

It is also possible to use \emph{JavaScript Object Notation} for structures by using \emph{string literals} for the keys:

\begin{lstlisting}
var point = { "x" : 1, "y" : -5 };
\end{lstlisting}
While any string literal is allowed, the field is only considered part of the type if it is a valid \tref{Haxe identifier}{define-identifier}. Otherwise, Haxe syntax does not allow expressing access to such a field, and \tref{reflection}{std-reflection} has to be employed through the use of \expr{Reflect.field} and \expr{Reflect.setField}.

\subsection{Class Notation for Structure Types}
\label{types-structure-class-notation}

When defining a structure type, Haxe allows using the same syntax as described in \Fullref{class-field}. The following \tref{typedef}{type-system-typedef} declares a \type{Point} type with variable fields \expr{x} and \expr{y} of type \type{Int}:

\begin{lstlisting}
typedef Point = {
    var x : Int;
    var y : Int;
}
\end{lstlisting}

\subsection{Optional Fields}
\label{types-structure-optional-fields}

\todo{I don't really know how these work yet.}

\subsection{Impact on Performance}
\label{types-structure-performance}

Using structures and, by extension, \tref{structural subtyping}{type-system-structural-subtyping} has no impact on performance when compiling to \tref{dynamic targets}{define-dynamic-target}. However, on \tref{static targets}{define-static-target} a dynamic lookup has to be performed which is typically slower than a static field access.



\section{Function Type}
\label{types-function}

\todo{It seems a bit convoluted explanations. Should we maybe start by "decoding" the meaning of  Void -> Void, then Int -> Bool -> Float, then maybe have samples using \$type}

The function type, along with the \tref{monomorph}{types-monomorph}, is a type which is usually well-hidden from Haxe users, yet present everywhere. We can make it surface by using \expr{\$type}, a special Haxe identifier which outputs the type its expression has during compilation :

\haxe{assets/FunctionType.hx}

There is a strong resemblance between the declaration of function \expr{test} and the output of the first \expr{\$type} expression, yet also a subtle difference:

\begin{itemize}
	\item \emph{Function arguments} are separated by the special arrow token \expr{->} instead of commas, and
	\item the \emph{function return type} appears at the end after another \expr{->}.
\end{itemize}

In either notation it is obvious that the function \expr{test} accepts a first argument of type \type{Int}, a second argument of type \type{String} and returns a value of type \type{Bool}. If a call to this function, such as \expr{test(1, "foo")}, is made within the second \expr{\$type} expression, the Haxe typer checks if \expr{1} can be assigned to \type{Int} and if \expr{"foo"} can be assigned to \type{String}. The type of the call is then equal to the type of the value \expr{test} returns, which is \type{Bool}.

If a function type has other function types as argument or return type, parentheses can be used to group them correctly. For example, \type{Int -> (Int -> Void) -> Void} represents a function which has a first argument of type \type{Int}, a second argument of function type \type{Int -> Void} and a return of \type{Void}.



\subsection{Optional Arguments}
\label{types-function-optional-arguments}

Optional arguments are declared by prefixing an argument identifier with a question mark \expr{?}:

\haxe[label=assets/OptionalArguments.hx]{assets/OptionalArguments.hx}
Function \expr{test} has two optional arguments: \expr{i} of type \type{Int} and \expr{s} of \type{String}. This is directly reflected in the function type output by line 3. 
This example program calls \expr{test} four times and prints its return value.

\begin{enumerate}
	\item The first call is made without any arguments.
	\item The second call is made with a singular argument \expr{1}.
	\item The third call is made with two arguments \expr{1} and \expr{"foo"}.
	\item The fourth call is made with a singular argument \expr{"foo"}.
\end{enumerate}
The output shows that optional arguments which are omitted from the call have a value of \expr{null}. This implies that the type of these arguments must admit \expr{null} as value, which raises the question of its \tref{nullability}{types-nullability}. The Haxe Compiler ensures that optional basic type arguments are nullable by inferring their type as \type{Null<T>} when compiling to a \tref{static target}{define-static-target}.

While the first three calls are intuitive, the fourth one might come as a surprise: It is indeed allowed to skip optional arguments if the supplied value is assignable to a later argument.


\subsection{Default values}
\label{types-function-default-values}

Haxe allows default values for arguments by assigning a \emph{constant value} to them:

\haxe{assets/DefaultValues.hx}
This example is very similar to the one from \Fullref{types-function-optional-arguments}, with the only difference being that the values \expr{12} and \expr{"bar"} are assigned to the function arguments \expr{i} and \expr{s} respectively. The effect is that the default values are used instead of \expr{null} should an argument be omitted from the call.

%TODO: Default values do not imply nullability, even if the value is \expr{null}. 

Default values in Haxe are not part of the type and are not replaced at call-site (unless the function is \tref{inlined}{class-field-inline}, which can be considered as a more typical approach. On some targets the compiler may still pass \expr{null} for omitted argument values and generate code similar to this into the function:
\begin{lstlisting}
	static function test(i = 12, s = "bar") {
		if (i == null) i = 12;
		if (s == null) s = "bar";
		return "i: " +i + ", s: " +s;
	}
\end{lstlisting}
This should be considered in performance-critical code where a solution without default values may sometimes be more viable.




\section{Dynamic}
\label{types-dynamic}

While Haxe has a static type system, this type system can, in effect, be turned off by using the \type{Dynamic} type. A \emph{dynamic value} can be assigned to anything; and anything can be assigned to it. This has several drawbacks:

\begin{itemize}
	\item The compiler can no longer type-check assignments, function calls and other constructs where specific types are expected.
	\item Certain optimizations, in particular when compiling to static targets, can no longer be employed.
	\item Some common errors, e.g. a typo in a field access, can not be caught at compile-time and likely cause an error at runtime.
	\item \Fullref{cr-dce} cannot detect used fields if they are used through \type{Dynamic}.
\end{itemize}
It is very easy to come up with examples where the usage of \type{Dynamic} can cause problems at runtime. Consider compiling the following two lines to a static target:

\begin{lstlisting}
var d:Dynamic = 1;
d.foo;
\end{lstlisting}

Trying to run a compiled program in the Flash Player yields an error \texttt{Property foo not found on Number and there is no default value}. Without \type{Dynamic}, this would have been detected at compile-time.

\trivia{Dynamic Inference before Haxe 3}{The Haxe 3 compiler never infers a type to \type{Dynamic}, so users must be explicit about it. Previous Haxe versions used to infer arrays of mixed types, e.g. \expr{[1, true, "foo"]}, as \type{Array<Dynamic>}. We found that this behavior introduced too many type problems and thus removed it for Haxe 3.}

Use of \type{Dynamic} should be minimized as there are better options in many situations but sometimes it is just practical to use it. Parts of the Haxe \Fullref{std-reflection} API use it and it is sometimes the best option when dealing with custom data structures that are not known at compile-time.

\type{Dynamic} behaves in a special way when being \tref{unified}{type-system-unification} with a \tref{monomorph}{types-monomorph}. Monomorphs are never bound to \type{Dynamic} which can have surprising results in examples such as this:

\haxe{assets/DynamicInferenceIssue.hx}

Although the return type of \expr{Json.parse} is \type{Dynamic}, the type of local variable \expr{json} is not bound to it and remains a monomorph. It is then inferred as an \tref{anonymous structure}{types-anonymous-structure} upon the \expr{json.length} field access, which causes the following \expr{json[0]} array access to fail. In order to avoid this, the variable \expr{json} can be explicitly typed as \type{Dynamic} by using \expr{var json:Dynamic}.

\trivia{Dynamic in the Standard Library}{Dynamic was quite frequent in the Haxe Standard Library before Haxe 3. With the continuous improvements of the Haxe type system the occurences of Dynamic were reduced over the releases leading to Haxe 3.}

\subsection{Dynamic with Type Parameter}
\label{types-dynamic-with-type-parameter}

\type{Dynamic} is a special type because it allows explicit declaration with and without a \tref{type parameter}{type-system-type-parameters}. If such a type parameter is provided, the semantics described in \Fullref{types-dynamic} are constrained to all fields being compatible with the parameter type:

\begin{lstlisting}
var att : Dynamic<String> = xml.attributes;
// valid, value is a String
att.name = "Nicolas";
// dito (this documentation is quite old)
att.age = "26";
// error, value is not a String
att.income = 0;
\end{lstlisting}


\subsection{Implementing Dynamic}
\label{types-dynamic-implemented}

Classes can \tref{implement}{types-interfaces} \type{Dynamic} and \type{Dynamic$<$T$>$} which enables arbitrary field access. In the former case, fields can have any type, in the latter, they are constrained to be compatible with the parameter type:

\haxe{assets/ImplementsDynamic.hx}

Implementing \type{Dynamic} does not satisfy the requirements of other implemented interfaces. The expected fields still have to be implemented explicitly.

Classes that implement \type{Dynamic} (with or without type parameter) can also utilize a special method named \expr{resolve}. If a \tref{read access}{define-read-access} is made and the field in question does not exist, the \expr{resolve} method is called with the field name as argument:

\haxe{assets/DynamicResolve.hx}



\section{Abstract}
\label{types-abstract}

An abstract type is a type which is actually a different type at run-time. It is a compile-time feature which defines types ``over'' concrete types in order to modify or augment their behavior:

\haxe[firstline=1,lastline=5]{assets/MyAbstract.hx}
We can derive the following from this example:

\begin{itemize}
	\item The keyword \expr{abstract} denotes that we are declaring an abstract type.
	\item \type{AbstractInt} is the name of the abstract and could be anything conforming to the rules for type identifiers.
	\item Enclosed in parenthesis \expr{()} is the \emph{underlying type} \type{Int}.
	\item Enclosed in curly braces \expr{$\left\{\right\}$} are the fields,
	\item which are a constructor function \expr{new} accepting one argument \expr{i} of type \type{Int}.
\end{itemize}

\define{Underlying Type}{define-underlying-type}{The underlying type of an abstract is the type which is used to represent said abstract at runtime. It is usually a concrete (i.e. non-abstract) type but could be another abstract type as well.}

The syntax is reminiscent of classes and the semantics are indeed similar. In fact, everything in the ``body'' of an abstract (that is everything after the opening curly brace) is parsed as class fields. Abstracts may have \tref{method}{class-field-method} fields and non-\tref{physical}{define-physical-field} \tref{property}{class-field-property} fields.

Furthermore, abstracts can be instantiated and used just like classes:

\haxe[firstline=7,lastline=12]{assets/MyAbstract.hx}
As mentioned before, abstracts are a compile-time feature, so it is interesting to see what the above actually generates. A suitable target for this is \target{JavaScript}, which tends to generate concise and clean code. Compiling the above (using \texttt{haxe -main MyAbstract -js myabstract.js}) shows this \target{JavaScript} code:

\begin{lstlisting}
var a = 12;
console.log(a);
\end{lstlisting}
The abstract type \type{Abstract} completely disappeared from the output and all that is left is a value of its underlying type, \type{Int}. This is because the constructor of \type{Abstract} is inlined - something we shall learn about later in the section \Fullref{class-field-inline} - and its inlined expression assigns a value to \expr{this}. This might be surprising when thinking in terms of classes. However, it is precisely what we want to express in the context of abstracts. Any \emph{inlined member method} of an abstract can assign to \expr{this}, and thus modify the ``internal value''.


A good question at this point is ``What happens if a member function is not declared inline'' because the code obviously has to go somewhere. Haxe creates a private class, known to be the \emph{implementation class}, which has all the abstract member functions as static functions accepting an additional first argument \expr{this} of the underlying type. While technically this is an implementation detail, it can be used for \tref{selective functions}{types-abstract-selective-functions}.



\trivia{Basic Types and abstracts}{Before the advent of abstract types, all basic types were implemented as extern classes or enums. While this nicely took care of some aspects such as \type{Int} being a ``child class'' of \type{Float}, it caused issues elsewhere. For instance, with \type{Float} being an extern class, it would unify with the empty structure \expr{\{\}}, making it impossible to constrain a type to accepting only real objects.}




\subsection{Implicit Casts}
\label{types-abstract-implicit-casts}

Unlike classes, abstracts allow defining implicit casts. There are two kinds of implicit casts:

\begin{description}
	\item[Direct:] Allows direct casting of the abstract type to or from another type. This is defined by adding \expr{to} and \expr{from} rules to the abstract type and is only allowed for types which unify with the underlying type of the abstract.
	\item[Class field:] Allows casting via calls to special cast functions. These functions are defined using \expr{@:to} and \expr{@:from} metadata. This kind of cast is allowed for all types.
\end{description}
The following code example shows an example of \emph{direct} casting:

\haxe{assets/ImplicitCastDirect.hx}
We declare \type{MyAbstract} as being \expr{from Int} and \expr{to Int}, meaning it can be assigned from \type{Int} and assigned to \type{Int}. This is shown in lines 9 and 10, where we first assign the \type{Int} \expr{12} to variable \expr{a} of type \type{MyAbstract} (this works due to the \expr{from Int} declaration) and then that abstract back to variable \expr{b} of type \type{Int} (this works due to the \expr{to Int} declaration).

Class field casts have the same semantics, but are defined completely differently:

\haxe{assets/ImplicitCastField.hx}
By adding \expr{@:from} to a static function, that function qualifies as implicit cast function from its argument type to the abstract. These functions must return a value of the abstract type. They must also be declared \expr{static}.

Similarly, adding \expr{@:to} to a function qualifies it as implicit cast function from the abstract to its return type. These functions are typically member-functions but they can be made \expr{static} and then serve as \tref{selective function}{types-abstract-selective-functions}.

In the example the method \expr{fromString} allows the assignment of value \expr{"3"} to variable \expr{a} of type \type{MyAbstract} while the method \expr{toArray} allows assigning that abstract to variable \expr{b} of type \type{Array<Int>}.

When using this kind of cast, calls to the cast-functions are inserted where required. This becomes obvious when looking at the \target{JavaScript} output:

\begin{lstlisting}
var a = _ImplicitCastField.MyAbstract_Impl_.fromString("3");
var b = _ImplicitCastField.MyAbstract_Impl_.toArray(a);
\end{lstlisting}
This can be further optimized by \tref{inlining}{class-field-inline} both cast functions, turning the output into the following:
\todo{please review your use of ``this'' and try to vary somewhat to avoid too much word repetition}

\begin{lstlisting}
var a = Std.parseInt("3");
var b = [a];
\end{lstlisting}
The \emph{selection algorithm} when assigning a type \expr{A} to a type \expr{B} with at least one of them being an abstract is simple:

\begin{enumerate}
	\item If \expr{A} is not an abstract, go to 3.
	\item If \expr{A} defines a \emph{to}-conversions that admits \expr{B}, go to 6.
	\item If \expr{B} is not an abstract, go to 5.
	\item If \expr{B} defines a \emph{from}-conversions that admits \expr{A}, go to 6.
	\item Stop, unification fails.
	\item Stop, unification succeeds.
\end{enumerate}

\input{assets/tikz/abstract-selection.tex}

By design, implicit casts are \emph{not transitive}, as the following example shows:

\haxe{assets/ImplicitTransitiveCast.hx}
While the individual casts from \type{A} to \type{B} and from \type{B} to \type{C} are allowed, a transitive cast from \type{A} to \type{C} is not. This is to avoid ambiguous cast-paths and retain a simple selection algorithm. 




\subsection{Operator Overloading}
\label{types-abstract-operator-overloading}

Abstracts allow overloading of unary and binary operators by adding the \expr{@:op} metadata to class fields:

\haxe{assets/AbstractOperatorOverload.hx}
By defining \expr{@:op(A * B)}, the function \expr{repeat} serves as operator method for the multiplication \expr{*} operator when the type of the left value is \type{MyAbstract} and the type of the right value is \type{Int}. The usage is shown in line 17, which turns into this when compiled to \target{JavaScript}:

\begin{lstlisting}
console.log(_AbstractOperatorOverload.
  MyAbstract_Impl_.repeat(a,3));
\end{lstlisting}
Similar to \tref{implicit casts with class fields}{types-abstract-implicit-casts}, a call to the overload method is inserted where required.

The example \expr{repeat} function is not commutative: While \expr{MyAbstract * Int} works, \expr{Int * MyAbstract} does not. If this should be allowed as well, the \expr{@:commutative} metadata can be added. If it should work \emph{only} for \expr{Int * MyAbstract}, but not for \expr{MyAbstract * Int}, the overload method can be made static, accepting \type{Int} and \type{MyAbstract} as first and second type respectively.

Overloading unary operators is analogous:

\haxe{assets/AbstractUnopOverload.hx}
Both binary and unary operator overloads can return any type.

\paragraph{Exposing underlying type operations}

It is also possible to omit the method body of a \expr{@:op} function, but only if the underlying type of the abstract allows the operation in question and if the resulting type can be assigned back to the abstract.

\haxe{assets/AbstractExposeTypeOperations.hx}

\todo{please review for correctness}


\subsection{Array Access}
\label{types-abstract-array-access}

Array access describes the particular syntax traditionally used to access the value in an array at a certain offset. This is usually only allowed with arguments of type \type{Int}. Nevertheless, with abstracts it is possible to define custom array access methods. The \tref{Haxe Standard Library}{std} uses this in its \type{Map} type, where the following two methods can be found:
\todo{You have marked ``Map'' for some reason}

\begin{lstlisting}
@:arrayAccess
public inline function get(key:K) {
  return this.get(key);
}
@:arrayAccess
public inline function arrayWrite(k:K, v:V):V {
	this.set(k, v);
	return v;
}
\end{lstlisting}
There are two kinds of array access methods:

\begin{itemize}
	\item If an \expr{@:arrayAccess} method accepts one argument, it is a getter.
	\item If an \expr{@:arrayAccess} method accepts two arguments, it is a setter.
\end{itemize}
The methods \expr{get} and \expr{arrayWrite} seen above then allow the following usage:

\haxe{assets/AbstractArrayAccess.hx}

At this point it should not be surprising to see that calls to the array access fields are inserted in the output:

\begin{lstlisting}
map.set("foo",1);
console.log(map.get("foo")); // 1
\end{lstlisting}

\paragraph{Order of array access resolving}
\label{types-abstract-array-access-order}

Due to a bug in Haxe versions before 3.2 the order of checked \expr{:arrayAccess} fields was undefined. This was fixed for Haxe 3.2 so that the fields are now consistently checked from top to bottom:

\haxe{assets/AbstractArrayAccessOrder.hx}

The array access \expr{a[0]} is resolved to the \expr{getInt1} field, leading to lower case \expr{f} being returned. The result might be different in Haxe versions before 3.2.

Fields which are defined earlier take priority even if they require an \tref{implicit cast}{types-abstract-implicit-casts}.


\subsection{Selective Functions}
\label{types-abstract-selective-functions}

Since the compiler promotes abstract member functions to static functions, it is possible to define static functions by hand and use them on an abstract instance. The semantics here are similar to those of \tref{static extensions}{lf-static-extension}, where the type of the first function argument determines for which types a function is defined:

\haxe{assets/SelectiveFunction.hx}
The method \expr{getString} of abstract \type{MyAbstract} is defined to accept a first argument of \type{MyAbstract$<$String$>$}. This causes it to be available on variable \expr{a} on line 14 (because the type of \expr{a} is \type{MyAbstract$<$String$>$}), but not on variable \expr{b} whose type is \type{MyAbstract$<$Int$>$}.

\trivia{Accidental Feature}{ Rather than having actually been designed, selective functions were discovered. After the idea was first mentioned, it required only minor adjustments in the compiler to make them work. Their discovery also lead to the introduction of multi-type abstracts, such as Map. }


\subsection{Enum abstracts}
\label{types-abstract-enum}
\since{3.1.0}

By adding the \expr{:enum} metadata to an abstract definition, that abstract can be used to define finite value sets:

\haxe{assets/AbstractEnum.hx}

The Haxe Compiler replaces all field access to the \type{HttpStatus} abstract with their values, as evident in the \target{JavaScript} output:

\begin{lstlisting}
Main.main = function() {
	var status = 404;
	var msg = Main.printStatus(status);
};
Main.printStatus = function(status) {
	switch(status) {
	case 404:
		return "Not found";
	case 405:
		return "Method not allowed";
	}
};
\end{lstlisting}

This is similar to accessing \tref{variables declared as inline}{class-field-inline}, but has several advantages:

\begin{itemize}
	\item The typer can ensure that all values of the set are typed correctly.
	\item The pattern matcher checks for \tref{exhaustiveness}{lf-pattern-matching-exhaustiveness} when \tref{matching}{lf-pattern-matching} an enum abstract.
	\item Defining fields requires less syntax.
\end{itemize}


\subsection{Forwarding abstract fields}
\label{types-abstract-forward}
\since{3.1.0}

When wrapping an underlying type, it is sometimes desirable to ``keep'' parts of its functionality. Because writing forwarding functions by hand is cumbersome, Haxe allows adding the \expr{:forward} metadata to an abstract type:

\haxe{assets/AbstractExpose.hx}

The \type{MyArray} abstract in this example wraps \type{Array}. Its \expr{:forward} metadata has two arguments which correspond to the field names to be forwarded to the underlying type. In this example, the \expr{main} method instantiates \type{MyArray} and accesses its \expr{push} and \expr{pop} methods. The commented line demonstrates that the \expr{length} field is not available.

As usual we can look at the \target{JavaScript} output to see how the code is being generated:

\begin{lstlisting}
Main.main = function() {
	var myArray = [];
	myArray.push(12);
	myArray.pop();
};
\end{lstlisting}

It is also possible to use \expr{:forward} without any arguments in order to forward all fields. Of course the Haxe Compiler still ensures that the field actually exists on the underlying type.

\trivia{Implemented as macro}{Both the \expr{:enum} and \expr{:forward} functionality were originally implemented using \tref{build macros}{macro-type-building}. While this worked nicely in non-macro code, it caused issues if these features were used from within macros. The implementation was subsequently moved to the compiler.}


\subsection{Core-type abstracts}
\label{types-abstract-core-type}

The Haxe Standard Library defines a set of basic types as core-type abstracts. They are identified by the \expr{:coreType} metadata and the lack of an underlying type declaration. These abstracts can still be understood to represent a different type. Still, that type is native to the Haxe target. 

Introducing custom core-type abstracts is rarely necessary in user code as it requires the Haxe target to be able to make sense of it. However, there could be interesting use-cases for authors of macros and new Haxe targets.

In contrast to opaque abstracts, core-type abstracts have the following properties:

\begin{itemize}
	\item They have no underlying type.
	\item They are considered nullable unless they are annotated with \expr{:notNull} metadata.
	\item They are allowed to declare \tref{array access}{types-abstract-array-access} functions without expressions.
	\item \tref{Operator overloading fields}{types-abstract-operator-overloading} that have no expression are not forced to adhere to the Haxe type semantics.
\end{itemize}



\section{Monomorph}
\label{types-monomorph}

A monomorph is a type which may, through \tref{unification}{type-system-unification}, morph into a different type later. We shall see details about this type when talking about \tref{type inference}{type-system-type-inference}.
